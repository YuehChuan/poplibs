#include "TestDevice.hpp"
#include <poplar/Engine.hpp>
#include "popops/codelets.hpp"
#include "poplibs_test/Util.hpp"

#define BOOST_TEST_MODULE ScaledAddSupervisor_fp
#include <boost/test/included/unit_test.hpp>


using namespace poplar;
using namespace poplar::program;
using namespace poplibs_test::util;

#define TOL 0.1 //tolerance of 0.1%

#define N 50

// Test data, generated by:
// python -c "import random; print [round(random.uniform(0, 100), 4)
//    for _ in range(N)]"

const float data[N] = {
  35.3107, 10.1772, 46.7381, 13.9262, 45.0335, 28.4897, 44.061, 10.2426,
  4.6414, 27.5753, 32.6721, 47.4974, 48.5426, 39.5682, 48.6913, 40.0116,
  30.6498, 2.2937, 30.3145, 0.1684, 42.6872, 41.7401, 23.5861, 9.019,
  20.1807, 24.7797, 3.1703, 2.0551, 0.5227, 48.4146, 3.8037, 1.7652,
  45.2364, 25.4629, 4.3781, 37.0106, 40.9803, 8.4458, 21.2012, 47.3511,
  48.7404, 46.3794, 24.0079, 9.6671, 45.042, 34.1226, 18.8406, 33.1556,
  24.9836, 2.2252
};

const float deltas[N] = {
  44.3124, 15.6979, 46.0087, 21.8252, 49.8885, 10.7233, 12.906, 30.8585,
  36.4511, 9.0345, 16.1252, 40.4499, 6.6671, 29.8331, 30.7544, 36.2115,
  19.7384, 47.8775, 43.8829, 36.7404, 10.6394, 26.8628, 34.0391, 34.9322,
  14.3799, 0.9228, 21.1643, 42.015, 11.4578, 30.5959, 35.4625, 4.8866,
  40.9464, 45.0164, 26.982, 6.6859, 38.8149, 18.2226, 5.452, 12.6861,
  13.2218, 5.0171, 45.1993, 45.5519, 25.1392, 14.3869, 6.1178, 23.3174,
  23.3041, 16.6587
};

const float expected[N] = {
  116.9962, 39.1147, 131.5505, 54.1588, 136.998, 48.257, 67.8519, 67.1272,
  71.8354, 44.2295, 62.3973, 122.0627, 60.8327, 94.5625, 105.384, 106.7639,
  67.0356, 90.5511, 111.2082, 67.8957, 62.2999, 91.259, 86.3338, 73.413,
  46.6886, 26.4808, 42.1846, 79.5056, 21.644, 104.8151, 69.1753, 10.7732,
  120.717, 108.4461, 54.1167, 49.3354, 112.5317, 42.0373, 31.2514, 70.7367,
  73.1135, 55.6279, 107.3283, 93.6375, 91.3836, 60.6434, 30.1182, 76.1389,
  67.9424, 32.9338
};

double atol(const Type &type) {
  return type == HALF ? 1e-7 : 1e-20;
}

void testScaledAddSupervisor(const char *vertex, const Type &type,
                                       const bool &constantFactor) {
  Device device = createTestDevice(TEST_TARGET);
  Graph graph(device);
  popops::addCodelets(graph);

  const auto &target = device.getTarget();

  Sequence prog;
  // create a ComputeSet for each test case of size = 1...N
  for (unsigned i = 1; i <= N; ++i) {
    auto cs = graph.addComputeSet("cs" + std::to_string(i));
    auto v = graph.addVertex(cs, vertex);
    graph.setTileMapping(v, 0);

    auto dataTensor = graph.addVariable(type, {i});
    graph.setTileMapping(dataTensor, 0);
    graph.connect(v["data"], dataTensor);

    graph.createHostWrite("data" + std::to_string(i), dataTensor);
    graph.createHostRead("data" + std::to_string(i), dataTensor);

    auto deltasTensor = graph.addVariable(type, {i});
    graph.setTileMapping(deltasTensor, 0);
    graph.connect(v["deltas"], deltasTensor);
    graph.createHostWrite("deltas" + std::to_string(i), deltasTensor);

    if(constantFactor) {
      graph.setInitialValue(v["K"], 1.8434);
    }
    else {
      auto factorTensor = graph.addVariable(type, {});
      graph.setTileMapping(factorTensor,0);
      graph.connect(v["factor"], factorTensor);
      graph.setInitialValue(factorTensor, 1.8434);
    }
    prog.add(Execute(cs));
  }

  Engine e(graph, prog, {{"target.textSectionSizeInBytes", "0x4000"}});
  e.load(device);

  std::unique_ptr<char[]> buffer(new char[N * target.getTypeSize(type)]);
  for (unsigned i = 1; i <= N; ++i) {
    copy(target, data, i, type, buffer.get());
    e.writeTensor("data" + std::to_string(i), buffer.get());
    copy(target, deltas, i, type, buffer.get());
    e.writeTensor("deltas" + std::to_string(i), buffer.get());
  }

  e.run();

  std::array<float, N> actual;
  for (unsigned i = 1; i <= N; ++i) {
    e.readTensor("data" + std::to_string(i), buffer.get());
    copy(target, type, buffer.get(), actual.data(), i);

    auto test = "n=" + std::to_string(i);
    BOOST_CHECK(checkIsClose(test, actual.data(), {i}, expected, i,
                             TOL, atol(type)));
  }
}

BOOST_AUTO_TEST_CASE(ScaledAddSupervisorHalfConst) {
  testScaledAddSupervisor("popops::ScaledAddSupervisor<half,true>", HALF, true);
}

BOOST_AUTO_TEST_CASE(ScaledAddSupervisorFloatConst) {
  testScaledAddSupervisor("popops::ScaledAddSupervisor<float,true>", FLOAT,
                                                                      true);
}

BOOST_AUTO_TEST_CASE(ScaledAddSupervisorHalfTensor) {
  testScaledAddSupervisor("popops::ScaledAddSupervisor<half,false>", HALF,
                                                                      false);
}

BOOST_AUTO_TEST_CASE(ScaledAddSupervisorFloatTensor) {
  testScaledAddSupervisor("popops::ScaledAddSupervisor<float,false>", FLOAT,
                                                                      false);
}
