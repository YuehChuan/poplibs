#ifdef __IPU__

#include "tileimplconsts.h"

// variables used to implement each pooling variant.
#define VERTEX_NAME @VERTEX_NAME@
#define CALC_FUNC(n, dst, src) @CALC_FUNC@
#define AVERAGE_RESULT @AVERAGE_RESULT@
#define IDENTITY_VALUE @IDENTITY_VALUE@

.globl VERTEX_NAME
.type VERTEX_NAME, @function

// vertex state
#define VERTEX_OUT_BASE_OFFSET 0 // ld32
#define VERTEX_OUT_DELTA_PTR_OFFSET 2
#define VERTEX_IN_OFFSET 3
#define VERTEX_WINDOW_SIZES_OFFSET 2 // ld32

// stack state
#define STACK_IN_PTR_PTR_OFFSET 0

// constants
#define SCALED_PTR32_SHL_BITS 2
#define VECTOR_LIST_BASE_BITS 20
#define VECTOR_LIST_LENGTH_BITS 12
#define DELTAN_OFFSET_BITS 18
#define DELTAN_LENGTH_BITS 14

#define LOG2_FLOAT_SIZEOF 2
#define LDCONST_MASK ((1 << 20) - 1)

// integer variables
#define inPtrPtr m0
#define outBase m1
#define outSize m2
#define windowSizes m3
#define outDelta m4
#define in m5
#define chanSize m6
#define chanSizeD2 m7
#define outDeltaPtr m8
#define windowSize m9
#define windowSizeM1 m10

// floating point variables
#define float a0
#define float2 a0:1
#define result a2
#define result2 a2:3
#define result2i0 a2
#define result2i1 a3
#define windowSizeFP a4
#define identity2 a6:7
#define identity2i0 a6
#define identity2i1 a7

// scratch variables
#define mscratch m11

.section .text.VERTEX_NAME
.align 8

// needed to align the rpts below when we use an extra 3 instructions to load
// the window size into the ARF.
#if AVERAGE_RESULT != 1
  nop
#endif
VERTEX_NAME:
  // load vertex state
  ld32 $outBase, $mvertex_base, $mzero, VERTEX_OUT_BASE_OFFSET
  ldz16 $outDeltaPtr, $mvertex_base, $mzero, VERTEX_OUT_DELTA_PTR_OFFSET

  // unpack base and length
  shr $outSize, $outBase, VECTOR_LIST_BASE_BITS
  brz $outSize, .Lepilogue

  shl $outBase, $outBase, VECTOR_LIST_LENGTH_BITS
  shr $outBase, $outBase, VECTOR_LIST_LENGTH_BITS

  {
    sub $outSize, $outSize, 1
    // preload the identity value into a scratch register here for free because
    // we can bundle all the necessary instructions, this saves us a cycle in
    // the window size is not zero case.
    setzi $identity2i0, IDENTITY_VALUE & LDCONST_MASK
  }
  {
    ldz16 $inPtrPtr, $mvertex_base, $mzero, VERTEX_IN_OFFSET
    or $identity2i0, $identity2i0, IDENTITY_VALUE & ~LDCONST_MASK
  }
  {
    ld32 $windowSizes, $mvertex_base, $mzero, VERTEX_WINDOW_SIZES_OFFSET
    mov $identity2i1, $identity2i0
  }

  // unpack scaled pointers.
  setzi $mscratch, TMEM_REGION0_BASE_ADDR
  shl $inPtrPtr, $inPtrPtr, SCALED_PTR32_SHL_BITS
  add $inPtrPtr, $inPtrPtr, $mscratch
  shl $outDeltaPtr, $outDeltaPtr, SCALED_PTR32_SHL_BITS
  add $outDeltaPtr, $outDeltaPtr, $mscratch

.Lout_loop:
  // save the current inPtrPtr on the stack we can go back to each for
  // each channel.
  st32 $inPtrPtr, $mzero, $mworker_base, STACK_IN_PTR_PTR_OFFSET

  // unpack offset and chanSize from the DeltaN
  ld32step $outDelta, $mzero, $outDeltaPtr+=, 1
  shr $chanSize, $outDelta, DELTAN_OFFSET_BITS
  shl $outDelta, $outDelta, DELTAN_LENGTH_BITS
  shr $outDelta, $outDelta, DELTAN_LENGTH_BITS

#if AVERAGE_RESULT == 1
  // load the window size in the ARF so we can use it to average the results.
  ldb16 $windowSizeFP, $windowSizes, $mzero, 0
  {
    ldz16step $windowSize, $mzero, $windowSizes+=, 1
    // zero extend the top half to transform the broadcasted 2x 16-bit vector
    // into an unsigned 32-bit int.
    sort4x16lo $windowSizeFP, $windowSizeFP, $azero
  }
  {
    // windowSize is minus 1 because we pipeline the first before each rpt
    // loop below.
    add $windowSizeM1, $windowSize, -1
    f32fromui32 $windowSizeFP, $windowSizeFP
  }
#else
  ldz16step $windowSize, $mzero, $windowSizes+=, 1

  // windowSize is minus 1 because we pipeline the first before each rpt
  // loop below.
  add $windowSizeM1, $windowSize, -1
#endif

  // branch if chanSize < 2
  shr $chanSizeD2, $chanSize, 1
  brz $chanSizeD2, .Lchan_rem

  // minus 1 for brnzdec.
  add $chanSizeD2, $chanSizeD2, -1
.Lchan_loop:
  {
    // reload the original inPtrPtr from the stack.
    ld32 $inPtrPtr, $mzero, $mworker_base, STACK_IN_PTR_PTR_OFFSET
    mov $result2, $identity2
  }

  // if window size is 0 we are done.
  brneg $windowSizeM1, .Lwindow_loop_epilogue

  ld32step $in, $mzero, $inPtrPtr+=, 1
  ld64 $float2, $in, $mzero, $chanSizeD2

  rpt $windowSizeM1, (.Lwindow_loop_end - .Lwindow_loop) / 8 - 1
.Lwindow_loop:
  {
    ld32step $in, $mzero, $inPtrPtr+=, 1
    CALC_FUNC(v2, $result2, $float2)
  }
  {
    ld64 $float2, $in, $mzero, $chanSizeD2
    fnop
  }
.Lwindow_loop_end:
  // process the final result.
  CALC_FUNC(v2, $result2, $float2)

#if AVERAGE_RESULT == 1
  f32div $result2i0, $result2i0, $windowSizeFP
  f32div $result2i1, $result2i1, $windowSizeFP
#endif

.Lwindow_loop_epilogue:
  st64 $result2, $outBase, $outDelta, $chanSizeD2

  brnzdec $chanSizeD2, .Lchan_loop

  // do we have one more to process?
.Lchan_rem:
  and $mscratch, $chanSize, 0x1
  brz $mscratch, .Lout_loop_epilogue

  // minus 1 so we can use chanSize as an offset to the final channel.
  add $chanSize, $chanSize, -1

  // scalar version of the channel loop above.
  {
    ld32 $inPtrPtr, $mzero, $mworker_base, STACK_IN_PTR_PTR_OFFSET
    mov $result2i0, $identity2i0
  }

  // if window size is 0 we are done.
  brneg $windowSizeM1, .Lchan_rem_window_loop_epilogue

  ld32step $in, $mzero, $inPtrPtr+=, 1
  ld32 $float, $in, $mzero, $chanSize

  rpt $windowSizeM1, (.Lchan_rem_window_loop_end - .Lchan_rem_window_loop)/8-1
.Lchan_rem_window_loop:
  {
    ld32step $in, $mzero, $inPtrPtr+=, 1
    CALC_FUNC(, $result, $float)
  }
  {
    ld32 $float, $in, $mzero, $chanSize
    fnop
  }
.Lchan_rem_window_loop_end:
  CALC_FUNC(, $result, $float)

#if AVERAGE_RESULT == 1
  f32div $result, $result, $windowSizeFP
#endif

.Lchan_rem_window_loop_epilogue:
  st32 $result, $outBase, $outDelta, $chanSize

  // intentional fallthrough

.Lout_loop_epilogue:
  brnzdec $outSize, .Lout_loop

  // intentional fallthrough.

.Lepilogue:
  exitz $mzero

.size VERTEX_NAME, .-VERTEX_NAME

#endif // __IPU__
